# flo - same species annotations lift over pipeline

Lift over is the process of transferring annotations from one genome assembly
to another. Usually lift over is done because there is a new, improved genome
assembly for the species and good quality annotations (maybe manually curated
or experimentally verified) are available on the old assembly.

The idea is simple: align the new assembly with the old one, process the
alignment data to define how a coordinate or coordinate range on the old
assembly should be transformed to the new assembly, transform the coordinates.

Tools to carry out lift over are available from [UCSC-Kent toolkit][1]. flo
combines them together into a pipeline that is easy to run, tweak, and extend.

## Lift over process

### Full genome alignment

This is typically done with BLAT. BLAT is fast, but doing full genome can take
substantial time. So the new assembly is split into chunks of < 5k nucleotides.
The chunks are then partitioned into 4-48 groups (depending on the number of
processes you can run parallely) and then BLATed against the old assembly.

Because it was chunks of the new assembly that was BLATed against the old
assembly the alignment coordinates will have to be changed back to how it
would look if the entire new assembly were BLATed against the old assembly.
This process is called "lift up".

Lift up is done with the `liftUp` tool from UCSC-Kent toolkit and with the help
of a lift up (`.lft`) file. A lift up file can be generated with the `faSplit`
tool (again from UCSC-Kent toolkit) when partitioning the new assembly.

See `liftUp` command's output to learn more about the format and the lift up
file generated by `flo` (using `faSplit`).

### Chaining, netting, filtering

`.psl` files containing alignment data from BLAT are converted into a [chain
file][2]. This is done with the `axtChain` tool. `axtChain` finds pairwise
alignments in the psl files (one between the same target and query sequence)
and joins them together, if overlapping and combining them will result in a
higher scoring longer alignment.

The resulting chain files are then sorted, merged, and then split with new
assembly as the reference. This bit doesn't make sense to me either, but is
important.

The resulting chain file is then "netted" using `chainNet` tool. Netting
organizes the chains in a hierarchal collection with the highest-scoring
non-overlapping chains on top, and their gaps filled in where possible by
lower-scoring chains, which in turn may have gaps filled in by lower-level
chains and so on.

The chain file in the previous step is then filtered against the net file
obtained above to get a lift over file that can be used for coordinate
transformation.

### Lift over

With the above lift over file annotations on the old assembly can be
transferred to the new assembly using `liftOver` tool.

If lifting annotations in GFF format, one can run into issues like:

1. mRNA mapped to different scaffolds.
2. mRNA with no CDS.
3. CDS with no mRNA.
4. Duplicated CDS ids (not sure why this happens).

So the resulting GFF should be processed further.

## How to use flo

As can be seen several tools need to be combined in steps to do lift over.
`flo` abstracts it all to 3 steps as described above: blat, chain, lift.

To use `flo` you must have Ruby 2.0 or higher (2.1 or higher recommended).

Then,

#### Download `flo`

    wget -c https://github.com/yeban/flo/archive/master.tar.gz -O flo.tar.gz
    tar xvf flo.tar.gz
    mv flo-master flo
    cd flo

#### Install UCSC-Kent tookit

    rake kent

#### Copy assemblies and annotations into flo/data

    mkdir data
    cp from/somewhere/A.fa data
    cp from/somewhere/B.fa data

The assemblies must be in FASTA format. Annotations must be in GFF format. For
annotations in other formats you will have to tweak flo a bit.

#### Run BLAT

    rake blat

GNU parallel command is needed for this.

The output will be in `run/blat` directory.

#### Chain the alignments

    rake chain

The output will be in `run/chain` directory.

#### Lift over annotations

    rake liftover

This will transfer annotations to new assembly and post-process the resulting
GFF as described above.

[`genometools`][3] is required for this. Without `genometools` both the lifted
and post-processed GFF will still be available to you. But may not be usable.

The output will be in `run/liftover` directory. `liftover.0.gff` is the result
of `liftOver`. `liftover.1.gff` is the result of post-processing and
`liftover.gff` is the final output (`liftover.1.gff` processed with
genometools).

## How are the results like

`flo` in itself doesn't do anything new or novel. It merely combines existing
tools into a usable fashion.

We used `flo` to migrate to do same species lift over with ~350Mb genome size.
94% of the annotations were mapped to the final assembly. Of the mapped
annotations, 90% were good.

## What if annotations are not in GFF format

You could convert to GFF or tweak the "lift over" part of flow. If your
annotations are in bed or gp format, you should consider tweaking `flo`
instead of converting to GFF.

If you want to use BAM format check out [`CrossMap`][4].

## I have a big genome. It's taking a very long time to run BLAT.

Try creating an ooc file.

```
sh "blat ../../data/#{SOURCE}.fa /dev/null /dev/null" \
     " -tileSize=11 -makeOoc=11.ooc -repMatch=100"

# ...

"blat -noHead -fastMap -ooc=11.ooc -minScore=100 -minIdentity=98" \
```

You can do this in the `joblist` task.

## Can I use flo for different species lift over / creating chain files

Not as it is. But you perhaps reuse the framework and much of the alignment and
chaining-netting step. blastz or another may be more suitable instead of blat.

[1]: http://hgdownload.cse.ucsc.edu/admin/exe/
[2]: http://genome.ucsc.edu/goldenpath/help/chain.html
[3]: http://genometools.org/
[4]: http://crossmap.sourceforge.net/
